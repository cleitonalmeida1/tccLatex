%====================================================================================================
% FaultRecovery: A ampliação da biblioteca de tolerância a falhas
%====================================================================================================
% TCC
%----------------------------------------------------------------------------------------------------
% Autor				: Cleiton Gonçalves de Almeida
% Orientador		: Kleber Kruger
% Instituição 		: UFMS - Universidade Federal do Mato Grosso do Sul
% Departamento		: CPCX - Sistema de Informação
%----------------------------------------------------------------------------------------------------
% Data de criação	: 10 de Maio de 2016
%====================================================================================================

\chapter{Anexos} \label{App:ApendiceA}

As tabelas deste apêndice mostram os resultados individuais dos testes sem a biblioteca \textit{FaultRecovery}, com a biblioteca \textit{FaultRecovery}, sem a classe TData e com a classe TData.

\includepdf[pages={1-17}]{anexos.pdf}

\begin{lstlisting}
#include "StateMachine.h"

TypeID TypeIDFactory::counter = 0;

Application *Application::instance = NULL;
\end{lstlisting}

\begin{lstlisting}
#ifndef STATEMACHINELIB_STATEMACHINE_H
#define STATEMACHINELIB_STATEMACHINE_H

#include "mbed.h"
#include "ConfigFile.h"
#include "Logger.h"
#include <map>
#include <fstream>
#include <iostream>

using namespace std;

/* -----------------------------------------------------------------------------
* Class Declarations
* ---------------------------------------------------------------------------*/
class TypeIDFactory;
class State;
class RecoveryPoint;
class StateMachine;
class Application;

/* -----------------------------------------------------------------------------
* Type Definitions
* ---------------------------------------------------------------------------*/
typedef int TypeID;

static const char *RECOVERY_FILE = "/local/state.txt";

/* -----------------------------------------------------------------------------
* Class Definitions
* ---------------------------------------------------------------------------*/
class TypeIDFactory {
private:

static TypeID counter;

TypeIDFactory() {
}

~TypeIDFactory() {
}

public:

template<typename T>
static TypeID getID() {
static TypeID id = counter++;
return id;
}
};

class State {
protected:

State() {
}

State(State &orig) {
}

virtual ~State() {
}

public:

virtual double getTimeLimit() {
return 0.0;
}

virtual void run(StateMachine &sm) = 0;
};

class RecoveryPoint {
protected:

RecoveryPoint() {
}

RecoveryPoint(RecoveryPoint &orig) {
}

virtual ~RecoveryPoint() {
}

public:

virtual void run(StateMachine &sm) = 0;
};

class StateMachine {
public:

StateMachine() :
configFile(RECOVERY_FILE), logger("/local/teste.txt") {
}

StateMachine(StateMachine &orig) :
recoveryPoints(orig.recoveryPoints), states(orig.states), current(
orig.current), configFile(RECOVERY_FILE), logger("/local/teste.txt") {
}

virtual ~StateMachine() {
}

template<class R, class S>
void addRecoveryPoint() {

TypeID id = TypeIDFactory::getID<S>();
recoveryPoints[id] = new R;
}

template<class S>
void setToState() {
StateMachine::current = TypeIDFactory::getID<S>();
serializeToFlash(current);
if (states[current] == NULL) {
addState<S>();
}
}

template<class S>
void start() {
setToState<S>();
run();
}

bool recoveryFrom(TypeID id) {
RecoveryPoint *recoveryPoint = recoveryPoints[id];
cout << "idRecovery = " << endl;
if (recoveryPoint == NULL) {
cout << "NULL" << endl;
return false;
}
recoveryPoints[id]->run(*this);
return true;
}

private:

std::map<TypeID, RecoveryPoint *> recoveryPoints;
std::map<TypeID, State *> states;
TypeID current;
ConfigFile configFile;
Logger logger;
Timer t;
template<class S>
void addState() {
TypeID id = TypeIDFactory::getID<S>();
states[id] = new S;
}

void run() {
static bool RUNNING = true;
while (RUNNING) {
t.reset();
t.start();
states[current]->run(*this);
logger.log("%f", t.read());
t.stop();
}
}

void serializeToFlash(TypeID id) {
configFile.setInt("estado", id);
configFile.save();
}
};

class Application {
protected:

Application() :
localFileSystem("local"), configFile(RECOVERY_FILE) {
}

//Application(Application &orig) : localFileSystem(orig.localFileSystem) { }

virtual ~Application() {
}

public:

template<class Application>
static Application* getInstance() {
return (Application *) instance;
}


template<class App>
static void initialize() {
cout << "initialize" << endl;
if (instance != NULL) {
cout << "Application has already been initialized";
}

static StateMachine sm;

instance = new App;
instance->setup();
instance->createRecoveryPoints(sm);

static bool RESET_BY_FAULT = true;
bool started = false;
cout << "RESET_BY_FAULT" << endl;
if (RESET_BY_FAULT && instance->recovery(sm)) {
cout << "RECOVERY" << endl;
started = true;
}
if (!started) {
instance->start(sm);
}
}

TypeID unserializeFromFlash() {
int a = atoi(configFile.get("estado"));
cout << "lendo = " << a << endl;
return a;
}

protected:

virtual void setup() {
}

virtual void createRecoveryPoints(StateMachine &sm) {
}

virtual void start(StateMachine &sm) = 0;

private:

static Application *instance;

LocalFileSystem localFileSystem;

ConfigFile configFile;

bool recovery(StateMachine &sm) {
if (configFile.load()) {
TypeID id = unserializeFromFlash();
cout << "id = " << id << endl;

return sm.recoveryFrom(id);
}
return false;
}
};

#endif //STATEMACHINELIB_STATEMACHINE_H
\end{lstlisting}

\begin{lstlisting}
#include <iostream>
using namespace std;

template<class T>
class TData {
	
	public:
	
	TData(){
		
	}
	
	TData(T t) {
		setData(t);
	}
	
	TData(T *t) {
		setData(t);
	}
	
	T getData();
	
	T* getDataObject();
	
	void injectFault();
	void injectFaultVetor();
	
	void setData(T data);
	void setData(T *data);
	
	TData& operator=(T data) {
		setData(data);
		return *this;
	}
	TData& operator=(TData& obj) {
		setData(obj.getData());
		return *this;
	}
	
	operator T() {
		return getData();
	}
	
	private:
	
	T d1;
	T d2;
	T d3;
	T dataObject;
	
	T getByVotting();
};

template<class T>
T TData<T>::getByVotting() {
	
	if (d1 == d2) {
		if (d1 != d3) {
			d3 = d1;
		}
	} else if (d1 == d3)
	d2 = d1;
	else if (d2 == d3)
	d1 = d2;
	else {
		cout << "throws exception" << endl;
	}
	
	return d1;
}
template<typename T>
T TData<T>::getData() {
	return getByVotting();
}

template<class T>
T* TData<T>::getDataObject() {
	d1 = dataObject;
	d2 = dataObject;
	d3 = dataObject;
	dataObject = getByVotting();
	return &dataObject;
}

template<typename T>
void TData<T>::setData(T data) {
	d1 = data;
	d2 = data;
	d3 = data;
	dataObject = data;
}
template<typename T>
void TData<T>::setData(T *data) {
	d1 = *data;
	d2 = *data;
	d3 = *data;
	dataObject = *data;
}


template<class T>
void TData<T>::injectFaultVetor() {
	d1 = 9;
}
\end{lstlisting}
